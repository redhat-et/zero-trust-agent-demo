apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policies
  namespace: spiffe-demo
data:
  user_permissions.rego: |
    package demo.users

    import rego.v1

    user_departments := {
        "alice": ["engineering", "finance"],
        "bob": ["finance", "admin"],
        "carol": ["hr"]
    }

    has_department(user_name, department) if {
        department_list := user_departments[user_name]
        department in department_list
    }

    get_departments(user_name) := departments if {
        departments := user_departments[user_name]
    }

    get_departments(user_name) := [] if {
        not user_departments[user_name]
    }

  agent_permissions.rego: |
    package demo.agents

    import rego.v1

    agent_capabilities := {
        "gpt4": ["engineering", "finance"],
        "claude": ["engineering", "finance", "admin", "hr"],
        "summarizer": ["finance"]
    }

    has_capability(agent_name, department) if {
        capability_list := agent_capabilities[agent_name]
        department in capability_list
    }

    get_capabilities(agent_name) := capabilities if {
        capabilities := agent_capabilities[agent_name]
    }

    get_capabilities(agent_name) := [] if {
        not agent_capabilities[agent_name]
    }

  delegation.rego: |
    package demo.authorization

    import rego.v1

    import data.demo.agents
    import data.demo.users

    # Document metadata is now passed in input.document_metadata
    # Expected structure:
    # {
    #   "required_department": "engineering",      # Single department OR
    #   "required_departments": ["finance", "hr"], # Multiple departments
    #   "sensitivity": "medium"
    # }

    parse_spiffe_id(spiffe_id) := result if {
        parts := split(spiffe_id, "/")
        count(parts) >= 2
        result := {"type": parts[count(parts) - 2], "name": parts[count(parts) - 1]}
    }

    # Get required departments from document metadata (handles both single and multiple)
    get_required_departments := deps if {
        deps := input.document_metadata.required_departments
    } else := [dep] if {
        dep := input.document_metadata.required_department
        dep != ""
    } else := []

    # Helper: Check if document is public (no required departments)
    is_public_document if {
        required := get_required_departments
        count(required) == 0
    }

    # Check if a set of permissions satisfies document requirements
    has_any_required_department(permissions) if {
        is_public_document
    }

    has_any_required_department(permissions) if {
        required := get_required_departments
        some dept in required
        dept in permissions
    }

    default allow := false

    # Rule 1: Public documents are always accessible
    allow if {
        is_public_document
    }

    # Rule 2: Direct user access (no agent delegation)
    allow if {
        not input.delegation
        caller := parse_spiffe_id(input.caller_spiffe_id)
        caller.type == "user"
        user_depts := users.get_departments(caller.name)
        has_any_required_department(user_depts)
    }

    # Rule 3: Delegated access (user delegates to agent)
    allow if {
        input.delegation
        user := parse_spiffe_id(input.delegation.user_spiffe_id)
        agent := parse_spiffe_id(input.delegation.agent_spiffe_id)
        user.type == "user"
        agent.type == "agent"
        user_depts := users.get_departments(user.name)
        agent_caps := agents.get_capabilities(agent.name)
        effective := {d | some d in user_depts; d in agent_caps}
        has_any_required_department(effective)
    }

    deny_reason := "Agent requests require user delegation context" if {
        not input.delegation
        caller := parse_spiffe_id(input.caller_spiffe_id)
        caller.type == "agent"
    }

    effective_permissions := result if {
        input.delegation
        user := parse_spiffe_id(input.delegation.user_spiffe_id)
        agent := parse_spiffe_id(input.delegation.agent_spiffe_id)
        user_depts := users.get_departments(user.name)
        agent_caps := agents.get_capabilities(agent.name)
        result := [d | some d in user_depts; d in agent_caps]
    }

    decision := {"allow": allow, "reason": reason, "details": details}

    reason := "Public document accessible to all" if {
        allow
        is_public_document
    }

    reason := "User has required department access" if {
        allow
        not input.delegation
        caller := parse_spiffe_id(input.caller_spiffe_id)
        caller.type == "user"
        not is_public_document
    }

    reason := "Both user and agent have required access (delegation)" if {
        allow
        input.delegation
        not is_public_document
    }

    reason := deny_reason if {
        not allow
        deny_reason
    }

    reason := "Insufficient permissions" if {
        not allow
        not deny_reason
    }

    details := {
        "document_id": input.document_id,
        "required_departments": get_required_departments,
        "caller_type": parse_spiffe_id(input.caller_spiffe_id).type,
        "caller_name": parse_spiffe_id(input.caller_spiffe_id).name
    } if {
        not input.delegation
    }

    details := {
        "document_id": input.document_id,
        "required_departments": get_required_departments,
        "user": parse_spiffe_id(input.delegation.user_spiffe_id).name,
        "agent": parse_spiffe_id(input.delegation.agent_spiffe_id).name,
        "user_departments": users.get_departments(parse_spiffe_id(input.delegation.user_spiffe_id).name),
        "agent_capabilities": agents.get_capabilities(parse_spiffe_id(input.delegation.agent_spiffe_id).name),
        "effective_permissions": effective_permissions
    } if {
        input.delegation
    }

  document_management.rego: |
    package demo.authorization.management

    import rego.v1

    import data.demo.users

    # Document management (CRUD) operations require admin department

    parse_spiffe_id(spiffe_id) := result if {
        parts := split(spiffe_id, "/")
        count(parts) >= 2
        result := {
            "type": parts[count(parts) - 2],
            "name": parts[count(parts) - 1]
        }
    }

    default allow_manage := false

    allow_manage if {
        caller := parse_spiffe_id(input.caller_spiffe_id)
        caller.type == "user"
        user_depts := users.get_departments(caller.name)
        "admin" in user_depts
    }

    reason := "User has admin department access" if {
        allow_manage
    }

    reason := "Management operations require admin department" if {
        not allow_manage
    }

    decision := {
        "allow": allow_manage,
        "reason": reason
    }
